# 测试规范

## 1. 测试策略概述

### 1.1 测试金字塔

我们采用测试金字塔策略，确保不同层级的测试覆盖：

```base
        /\     E2E Tests (端到端测试)
       /  \    - 用户场景测试
      /    \   - 关键业务流程
     /______\  
    /        \  Integration Tests (集成测试)
   /          \ - API 接口测试
  /            \- 组件集成测试
 /______________\
/                \ Unit Tests (单元测试)
\                / - 函数/方法测试
 \______________/  - 组件单元测试
```

### 1.2 测试覆盖率目标

- **单元测试覆盖率**: ≥ 80%
- **集成测试覆盖率**: ≥ 60%
- **端到端测试覆盖率**: 核心业务流程 100%

### 1.3 测试环境

- **开发环境**: 本地开发时的快速测试
- **测试环境**: CI/CD 自动化测试
- **预发布环境**: 生产前的最终验证

## 2. 前端测试规范

### 2.1 单元测试

#### 2.1.1 Vue 组件测试

使用 Vue Test Utils + Vitest 进行组件测试：

```typescript
// tests/components/UserCard.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import UserCard from '@/components/UserCard.vue'
import type { User } from '@/types/user'

// 模拟用户数据
const mockUser: User = {
  id: 1,
  username: 'testuser',
  email: 'test@example.com',
  realName: '测试用户',
  avatar: 'https://example.com/avatar.jpg',
  status: 1,
  roles: [],
  createdAt: '2023-01-01T00:00:00Z',
  updatedAt: '2023-01-01T00:00:00Z'
}

describe('UserCard', () => {
  beforeEach(() => {
    // 设置 Pinia
    setActivePinia(createPinia())
  })

  it('应该正确渲染用户信息', () => {
    const wrapper = mount(UserCard, {
      props: {
        user: mockUser
      }
    })

    // 验证用户名显示
    expect(wrapper.find('[data-testid="username"]').text()).toBe(mockUser.username)
    
    // 验证邮箱显示
    expect(wrapper.find('[data-testid="email"]').text()).toBe(mockUser.email)
    
    // 验证头像
    const avatar = wrapper.find('[data-testid="avatar"]')
    expect(avatar.attributes('src')).toBe(mockUser.avatar)
  })

  it('应该在只读模式下隐藏操作按钮', () => {
    const wrapper = mount(UserCard, {
      props: {
        user: mockUser,
        readonly: true
      }
    })

    // 验证编辑按钮不存在
    expect(wrapper.find('[data-testid="edit-button"]').exists()).toBe(false)
    
    // 验证删除按钮不存在
    expect(wrapper.find('[data-testid="delete-button"]').exists()).toBe(false)
  })

  it('应该正确触发编辑事件', async () => {
    const wrapper = mount(UserCard, {
      props: {
        user: mockUser
      }
    })

    // 点击编辑按钮
    await wrapper.find('[data-testid="edit-button"]').trigger('click')
    
    // 验证事件被触发
    expect(wrapper.emitted('edit')).toBeTruthy()
    expect(wrapper.emitted('edit')?.[0]).toEqual([mockUser.id])
  })

  it('应该正确触发删除事件', async () => {
    const wrapper = mount(UserCard, {
      props: {
        user: mockUser
      }
    })

    // 点击删除按钮
    await wrapper.find('[data-testid="delete-button"]').trigger('click')
    
    // 验证事件被触发
    expect(wrapper.emitted('delete')).toBeTruthy()
    expect(wrapper.emitted('delete')?.[0]).toEqual([mockUser.id])
  })

  it('应该正确处理缺失的头像', () => {
    const userWithoutAvatar = { ...mockUser, avatar: undefined }
    
    const wrapper = mount(UserCard, {
      props: {
        user: userWithoutAvatar
      }
    })

    // 验证默认头像
    const avatar = wrapper.find('[data-testid="avatar"]')
    expect(avatar.attributes('src')).toContain('default-avatar')
  })
})
```

#### 2.1.2 Composables 测试

```typescript
// tests/composables/useUser.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { createPinia, setActivePinia } from 'pinia'
import { useUser } from '@/composables/useUser'
import { userAPI } from '@/api/user'
import type { User } from '@/types/user'

// 模拟 API
vi.mock('@/api/user', () => ({
  userAPI: {
    getUsers: vi.fn(),
    getUserById: vi.fn(),
    createUser: vi.fn(),
    updateUser: vi.fn(),
    deleteUser: vi.fn()
  }
}))

const mockUsers: User[] = [
  {
    id: 1,
    username: 'user1',
    email: 'user1@example.com',
    realName: '用户1',
    status: 1,
    roles: [],
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z'
  },
  {
    id: 2,
    username: 'user2',
    email: 'user2@example.com',
    realName: '用户2',
    status: 1,
    roles: [],
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z'
  }
]

describe('useUser', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.clearAllMocks()
  })

  it('应该正确获取用户列表', async () => {
    // 模拟 API 响应
    vi.mocked(userAPI.getUsers).mockResolvedValue({
      items: mockUsers,
      total: 2,
      page: 1,
      size: 20,
      totalPages: 1
    })

    const { users, loading, fetchUsers } = useUser()

    // 初始状态
    expect(loading.value).toBe(false)
    expect(users.value).toEqual([])

    // 获取用户列表
    await fetchUsers()

    // 验证结果
    expect(loading.value).toBe(false)
    expect(users.value).toEqual(mockUsers)
    expect(userAPI.getUsers).toHaveBeenCalledWith({
      page: 1,
      size: 20,
      keyword: undefined,
      status: undefined
    })
  })

  it('应该正确处理加载状态', async () => {
    let resolvePromise: (value: any) => void
    const promise = new Promise(resolve => {
      resolvePromise = resolve
    })
    
    vi.mocked(userAPI.getUsers).mockReturnValue(promise)

    const { loading, fetchUsers } = useUser()

    // 开始加载
    const fetchPromise = fetchUsers()
    expect(loading.value).toBe(true)

    // 完成加载
    resolvePromise!({
      items: mockUsers,
      total: 2,
      page: 1,
      size: 20,
      totalPages: 1
    })
    
    await fetchPromise
    expect(loading.value).toBe(false)
  })

  it('应该正确处理错误', async () => {
    const error = new Error('API Error')
    vi.mocked(userAPI.getUsers).mockRejectedValue(error)

    const { users, error: userError, fetchUsers } = useUser()

    await fetchUsers()

    expect(users.value).toEqual([])
    expect(userError.value).toBe(error)
  })

  it('应该正确创建用户', async () => {
    const newUser = {
      username: 'newuser',
      email: 'newuser@example.com',
      password: 'password123',
      realName: '新用户',
      roleIds: [1]
    }

    const createdUser = {
      id: 3,
      ...newUser,
      status: 1,
      roles: [],
      createdAt: '2023-01-01T00:00:00Z',
      updatedAt: '2023-01-01T00:00:00Z'
    }

    vi.mocked(userAPI.createUser).mockResolvedValue(createdUser)

    const { users, createUser } = useUser()

    await createUser(newUser)

    expect(userAPI.createUser).toHaveBeenCalledWith(newUser)
    expect(users.value).toContain(createdUser)
  })
})
```

#### 2.1.3 Store 测试

```typescript
// tests/stores/user.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { createPinia, setActivePinia } from 'pinia'
import { useUserStore } from '@/stores/user'
import { userAPI } from '@/api/user'
import type { User, LoginRequest } from '@/types/user'

// 模拟 API
vi.mock('@/api/user')

// 模拟 localStorage
const localStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn()
}
Object.defineProperty(window, 'localStorage', {
  value: localStorageMock
})

const mockUser: User = {
  id: 1,
  username: 'testuser',
  email: 'test@example.com',
  realName: '测试用户',
  status: 1,
  roles: [],
  createdAt: '2023-01-01T00:00:00Z',
  updatedAt: '2023-01-01T00:00:00Z'
}

const mockLoginResponse = {
  token: 'mock-jwt-token',
  userInfo: mockUser,
  permissions: ['user:read', 'user:write']
}

describe('useUserStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.clearAllMocks()
  })

  it('应该正确初始化状态', () => {
    const userStore = useUserStore()

    expect(userStore.userInfo).toBeNull()
    expect(userStore.token).toBe('')
    expect(userStore.permissions).toEqual([])
    expect(userStore.isLoggedIn).toBe(false)
  })

  it('应该正确处理登录', async () => {
    vi.mocked(userAPI.login).mockResolvedValue(mockLoginResponse)

    const userStore = useUserStore()
    const loginData: LoginRequest = {
      username: 'testuser',
      password: 'password123',
      rememberMe: false
    }

    await userStore.login(loginData)

    // 验证状态更新
    expect(userStore.token).toBe(mockLoginResponse.token)
    expect(userStore.userInfo).toEqual(mockLoginResponse.userInfo)
    expect(userStore.permissions).toEqual(mockLoginResponse.permissions)
    expect(userStore.isLoggedIn).toBe(true)

    // 验证本地存储
    expect(localStorageMock.setItem).toHaveBeenCalledWith('token', mockLoginResponse.token)
    expect(localStorageMock.setItem).toHaveBeenCalledWith(
      'userInfo',
      JSON.stringify(mockLoginResponse.userInfo)
    )
  })

  it('应该正确处理登出', () => {
    const userStore = useUserStore()
    
    // 设置初始状态
    userStore.token = 'some-token'
    userStore.userInfo = mockUser
    userStore.permissions = ['user:read']

    userStore.logout()

    // 验证状态清除
    expect(userStore.token).toBe('')
    expect(userStore.userInfo).toBeNull()
    expect(userStore.permissions).toEqual([])
    expect(userStore.isLoggedIn).toBe(false)

    // 验证本地存储清除
    expect(localStorageMock.removeItem).toHaveBeenCalledWith('token')
    expect(localStorageMock.removeItem).toHaveBeenCalledWith('userInfo')
  })

  it('应该正确检查权限', () => {
    const userStore = useUserStore()
    userStore.permissions = ['user:read', 'user:write', 'admin:read']

    // 测试单个权限
    expect(userStore.hasPermission('user:read')).toBe(true)
    expect(userStore.hasPermission('user:delete')).toBe(false)

    // 测试权限函数
    const hasUserRead = userStore.hasPermission('user:read')
    expect(hasUserRead).toBe(true)
  })

  it('应该正确更新用户信息', () => {
    const userStore = useUserStore()
    userStore.userInfo = mockUser

    const updateData = {
      realName: '更新的用户名',
      email: 'updated@example.com'
    }

    userStore.updateUserInfo(updateData)

    expect(userStore.userInfo).toEqual({
      ...mockUser,
      ...updateData
    })

    expect(localStorageMock.setItem).toHaveBeenCalledWith(
      'userInfo',
      JSON.stringify(userStore.userInfo)
    )
  })

  it('应该正确处理登录错误', async () => {
    const error = new Error('登录失败')
    vi.mocked(userAPI.login).mockRejectedValue(error)

    const userStore = useUserStore()
    const loginData: LoginRequest = {
      username: 'testuser',
      password: 'wrongpassword',
      rememberMe: false
    }

    await expect(userStore.login(loginData)).rejects.toThrow('登录失败')

    // 验证状态未改变
    expect(userStore.token).toBe('')
    expect(userStore.userInfo).toBeNull()
    expect(userStore.isLoggedIn).toBe(false)
  })
})
```

### 2.2 集成测试

#### 2.2.1 页面集成测试

```typescript
// tests/integration/UserManagement.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createRouter, createWebHistory } from 'vue-router'
import { createPinia, setActivePinia } from 'pinia'
import { ElMessage } from 'element-plus'
import UserManagement from '@/views/UserManagement.vue'
import { userAPI } from '@/api/user'
import type { User } from '@/types/user'

// 模拟 API
vi.mock('@/api/user')
vi.mock('element-plus', () => ({
  ElMessage: {
    success: vi.fn(),
    error: vi.fn(),
    warning: vi.fn()
  }
}))

const mockUsers: User[] = [
  {
    id: 1,
    username: 'user1',
    email: 'user1@example.com',
    realName: '用户1',
    status: 1,
    roles: [],
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z'
  },
  {
    id: 2,
    username: 'user2',
    email: 'user2@example.com',
    realName: '用户2',
    status: 1,
    roles: [],
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z'
  }
]

describe('UserManagement Integration', () => {
  let router: any
  
  beforeEach(async () => {
    setActivePinia(createPinia())
    
    router = createRouter({
      history: createWebHistory(),
      routes: [
        { path: '/users', component: UserManagement }
      ]
    })
    
    await router.push('/users')
    vi.clearAllMocks()
  })

  it('应该正确加载和显示用户列表', async () => {
    // 模拟 API 响应
    vi.mocked(userAPI.getUsers).mockResolvedValue({
      items: mockUsers,
      total: 2,
      page: 1,
      size: 20,
      totalPages: 1
    })

    const wrapper = mount(UserManagement, {
      global: {
        plugins: [router]
      }
    })

    // 等待组件挂载和数据加载
    await wrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 100))

    // 验证用户列表显示
    const userCards = wrapper.findAll('[data-testid="user-card"]')
    expect(userCards).toHaveLength(2)
    
    // 验证第一个用户信息
    expect(userCards[0].find('[data-testid="username"]').text()).toBe('user1')
    expect(userCards[0].find('[data-testid="email"]').text()).toBe('user1@example.com')
  })

  it('应该正确处理搜索功能', async () => {
    // 初始加载
    vi.mocked(userAPI.getUsers).mockResolvedValue({
      items: mockUsers,
      total: 2,
      page: 1,
      size: 20,
      totalPages: 1
    })

    const wrapper = mount(UserManagement, {
      global: {
        plugins: [router]
      }
    })

    await wrapper.vm.$nextTick()

    // 搜索特定用户
    const filteredUsers = [mockUsers[0]]
    vi.mocked(userAPI.getUsers).mockResolvedValue({
      items: filteredUsers,
      total: 1,
      page: 1,
      size: 20,
      totalPages: 1
    })

    // 输入搜索关键词
    const searchInput = wrapper.find('[data-testid="search-input"]')
    await searchInput.setValue('user1')
    
    // 点击搜索按钮
    await wrapper.find('[data-testid="search-button"]').trigger('click')
    await wrapper.vm.$nextTick()

    // 验证 API 调用
    expect(userAPI.getUsers).toHaveBeenLastCalledWith({
      page: 1,
      size: 20,
      keyword: 'user1',
      status: undefined
    })
  })

  it('应该正确处理用户创建流程', async () => {
    const newUser = {
      id: 3,
      username: 'newuser',
      email: 'newuser@example.com',
      realName: '新用户',
      status: 1,
      roles: [],
      createdAt: '2023-01-01T00:00:00Z',
      updatedAt: '2023-01-01T00:00:00Z'
    }

    // 模拟创建用户 API
    vi.mocked(userAPI.createUser).mockResolvedValue(newUser)
    
    // 模拟获取用户列表 API
    vi.mocked(userAPI.getUsers).mockResolvedValue({
      items: mockUsers,
      total: 2,
      page: 1,
      size: 20,
      totalPages: 1
    })

    const wrapper = mount(UserManagement, {
      global: {
        plugins: [router]
      }
    })

    await wrapper.vm.$nextTick()

    // 点击创建用户按钮
    await wrapper.find('[data-testid="create-user-button"]').trigger('click')
    await wrapper.vm.$nextTick()

    // 验证对话框打开
    expect(wrapper.find('[data-testid="user-dialog"]').exists()).toBe(true)

    // 填写表单
    await wrapper.find('[data-testid="username-input"]').setValue('newuser')
    await wrapper.find('[data-testid="email-input"]').setValue('newuser@example.com')
    await wrapper.find('[data-testid="realname-input"]').setValue('新用户')
    await wrapper.find('[data-testid="password-input"]').setValue('password123')

    // 提交表单
    await wrapper.find('[data-testid="submit-button"]').trigger('click')
    await wrapper.vm.$nextTick()

    // 验证 API 调用
    expect(userAPI.createUser).toHaveBeenCalledWith({
      username: 'newuser',
      email: 'newuser@example.com',
      realName: '新用户',
      password: 'password123',
      roleIds: []
    })

    // 验证成功消息
    expect(ElMessage.success).toHaveBeenCalledWith('用户创建成功')
  })

  it('应该正确处理用户删除流程', async () => {
    // 模拟删除用户 API
    vi.mocked(userAPI.deleteUser).mockResolvedValue(undefined)
    
    // 模拟获取用户列表 API
    vi.mocked(userAPI.getUsers).mockResolvedValue({
      items: mockUsers,
      total: 2,
      page: 1,
      size: 20,
      totalPages: 1
    })

    const wrapper = mount(UserManagement, {
      global: {
        plugins: [router]
      }
    })

    await wrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 100))

    // 点击第一个用户的删除按钮
    const firstUserCard = wrapper.findAll('[data-testid="user-card"]')[0]
    await firstUserCard.find('[data-testid="delete-button"]').trigger('click')
    await wrapper.vm.$nextTick()

    // 验证确认对话框
    expect(wrapper.find('[data-testid="confirm-dialog"]').exists()).toBe(true)

    // 确认删除
    await wrapper.find('[data-testid="confirm-delete-button"]').trigger('click')
    await wrapper.vm.$nextTick()

    // 验证 API 调用
    expect(userAPI.deleteUser).toHaveBeenCalledWith(1)

    // 验证成功消息
    expect(ElMessage.success).toHaveBeenCalledWith('用户删除成功')
  })

  it('应该正确处理错误情况', async () => {
    // 模拟 API 错误
    const error = new Error('网络错误')
    vi.mocked(userAPI.getUsers).mockRejectedValue(error)

    const wrapper = mount(UserManagement, {
      global: {
        plugins: [router]
      }
    })

    await wrapper.vm.$nextTick()
    await new Promise(resolve => setTimeout(resolve, 100))

    // 验证错误消息
    expect(ElMessage.error).toHaveBeenCalledWith('加载用户列表失败')
    
    // 验证错误状态显示
    expect(wrapper.find('[data-testid="error-message"]').exists()).toBe(true)
  })
})
```

## 3. 后端测试规范

### 3.1 单元测试

#### 3.1.1 服务层测试

```python
# tests/test_services/test_user_service.py
import pytest
from unittest.mock import Mock, patch
from sqlalchemy.orm import Session
from datetime import datetime

from app.services.user_service import UserService
from app.models.user import User
from app.models.role import Role
from app.schemas.user import UserCreate, UserUpdate
from app.core.exceptions import UserNotFoundException, UserAlreadyExistsException

class TestUserService:
    """用户服务测试类"""
    
    def setup_method(self):
        """测试前置设置"""
        self.db_mock = Mock(spec=Session)
        self.user_service = UserService(self.db_mock)
        
        # 模拟用户数据
        self.mock_user = User(
            id=1,
            username="testuser",
            email="test@example.com",
            real_name="测试用户",
            password_hash="hashed_password",
            status=1,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        
        self.mock_role = Role(
            id=1,
            name="user",
            description="普通用户"
        )
    
    @pytest.mark.asyncio
    async def test_get_users_success(self):
        """测试获取用户列表成功"""
        # 模拟数据库查询
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.count.return_value = 1
        query_mock.offset.return_value = query_mock
        query_mock.limit.return_value = query_mock
        query_mock.all.return_value = [self.mock_user]
        
        # 执行测试
        result = await self.user_service.get_users(page=1, size=20)
        
        # 验证结果
        assert result.total == 1
        assert result.page == 1
        assert result.size == 20
        assert len(result.items) == 1
        assert result.items[0] == self.mock_user
    
    @pytest.mark.asyncio
    async def test_get_users_with_keyword_filter(self):
        """测试带关键词搜索的用户列表"""
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.count.return_value = 1
        query_mock.offset.return_value = query_mock
        query_mock.limit.return_value = query_mock
        query_mock.all.return_value = [self.mock_user]
        
        # 执行测试
        await self.user_service.get_users(keyword="test")
        
        # 验证过滤条件被应用
        assert query_mock.filter.called
    
    @pytest.mark.asyncio
    async def test_get_user_by_id_success(self):
        """测试根据ID获取用户成功"""
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = self.mock_user
        
        # 执行测试
        result = await self.user_service.get_user_by_id(1)
        
        # 验证结果
        assert result == self.mock_user
        self.db_mock.query.assert_called_with(User)
    
    @pytest.mark.asyncio
    async def test_get_user_by_id_not_found(self):
        """测试根据ID获取用户不存在"""
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = None
        
        # 执行测试
        result = await self.user_service.get_user_by_id(999)
        
        # 验证结果
        assert result is None
    
    @pytest.mark.asyncio
    async def test_create_user_success(self):
        """测试创建用户成功"""
        # 模拟用户不存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = None
        
        # 模拟角色查询
        role_query_mock = Mock()
        self.db_mock.query.return_value = role_query_mock
        role_query_mock.filter.return_value = role_query_mock
        role_query_mock.all.return_value = [self.mock_role]
        
        # 创建用户数据
        user_data = UserCreate(
            username="newuser",
            email="newuser@example.com",
            password="password123",
            real_name="新用户",
            role_ids=[1]
        )
        
        with patch('app.core.security.get_password_hash') as hash_mock:
            hash_mock.return_value = "hashed_password"
            
            # 执行测试
            result = await self.user_service.create_user(user_data)
            
            # 验证数据库操作
            self.db_mock.add.assert_called_once()
            self.db_mock.commit.assert_called_once()
            self.db_mock.refresh.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_create_user_already_exists(self):
        """测试创建用户时用户名已存在"""
        # 模拟用户已存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = self.mock_user
        
        user_data = UserCreate(
            username="testuser",
            email="test@example.com",
            password="password123",
            real_name="测试用户",
            role_ids=[1]
        )
        
        # 执行测试并验证异常
        with pytest.raises(UserAlreadyExistsException):
            await self.user_service.create_user(user_data)
    
    @pytest.mark.asyncio
    async def test_update_user_success(self):
        """测试更新用户成功"""
        # 模拟用户存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = self.mock_user
        
        # 更新数据
        update_data = UserUpdate(
            real_name="更新的用户名",
            email="updated@example.com"
        )
        
        # 执行测试
        result = await self.user_service.update_user(1, update_data)
        
        # 验证结果
        assert result == self.mock_user
        assert self.mock_user.real_name == "更新的用户名"
        assert self.mock_user.email == "updated@example.com"
        self.db_mock.commit.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_update_user_not_found(self):
        """测试更新不存在的用户"""
        # 模拟用户不存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = None
        
        update_data = UserUpdate(real_name="更新的用户名")
        
        # 执行测试
        result = await self.user_service.update_user(999, update_data)
        
        # 验证结果
        assert result is None
    
    @pytest.mark.asyncio
    async def test_delete_user_success(self):
        """测试删除用户成功"""
        # 模拟用户存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = self.mock_user
        
        # 执行测试
        result = await self.user_service.delete_user(1)
        
        # 验证结果
        assert result is True
        self.db_mock.delete.assert_called_once_with(self.mock_user)
        self.db_mock.commit.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_delete_user_not_found(self):
        """测试删除不存在的用户"""
        # 模拟用户不存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = None
        
        # 执行测试
        result = await self.user_service.delete_user(999)
        
        # 验证结果
        assert result is False
        self.db_mock.delete.assert_not_called()
    
    @pytest.mark.asyncio
    async def test_authenticate_user_success(self):
        """测试用户认证成功"""
        # 模拟用户存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = self.mock_user
        
        with patch('app.core.security.verify_password') as verify_mock:
            verify_mock.return_value = True
            
            # 执行测试
            result = await self.user_service.authenticate_user("testuser", "password123")
            
            # 验证结果
            assert result == self.mock_user
            verify_mock.assert_called_once_with("password123", "hashed_password")
    
    @pytest.mark.asyncio
    async def test_authenticate_user_wrong_password(self):
        """测试用户认证密码错误"""
        # 模拟用户存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = self.mock_user
        
        with patch('app.core.security.verify_password') as verify_mock:
            verify_mock.return_value = False
            
            # 执行测试
            result = await self.user_service.authenticate_user("testuser", "wrongpassword")
            
            # 验证结果
            assert result is None
    
    @pytest.mark.asyncio
    async def test_authenticate_user_not_found(self):
        """测试用户认证用户不存在"""
        # 模拟用户不存在
        query_mock = Mock()
        self.db_mock.query.return_value = query_mock
        query_mock.filter.return_value = query_mock
        query_mock.first.return_value = None
        
        # 执行测试
        result = await self.user_service.authenticate_user("nonexistent", "password123")
        
        # 验证结果
        assert result is None
```

#### 3.1.2 API 路由测试

```python
# tests/test_api/test_users.py
import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, Mock
from datetime import datetime

from app.main import app
from app.models.user import User
from app.schemas.user import UserResponse

client = TestClient(app)

class TestUserAPI:
    """用户API测试类"""
    
    def setup_method(self):
        """测试前置设置"""
        self.mock_user = User(
            id=1,
            username="testuser",
            email="test@example.com",
            real_name="测试用户",
            status=1,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        
        # 模拟认证用户
        self.auth_headers = {
            "Authorization": "Bearer mock-jwt-token"
        }
    
    @patch('app.core.deps.get_current_user')
    @patch('app.services.user_service.UserService.get_users')
    def test_get_users_success(self, mock_get_users, mock_get_current_user):
        """测试获取用户列表成功"""
        # 模拟当前用户
        mock_get_current_user.return_value = self.mock_user
        
        # 模拟服务响应
        mock_response = Mock()
        mock_response.items = [self.mock_user]
        mock_response.total = 1
        mock_response.page = 1
        mock_response.size = 20
        mock_response.total_pages = 1
        mock_get_users.return_value = mock_response
        
        # 发送请求
        response = client.get("/api/v1/users/", headers=self.auth_headers)
        
        # 验证响应
        assert response.status_code == 200
        data = response.json()
        assert data["total"] == 1
        assert len(data["items"]) == 1
        assert data["items"][0]["username"] == "testuser"
    
    @patch('app.core.deps.get_current_user')
    @patch('app.services.user_service.UserService.get_users')
    def test_get_users_with_pagination(self, mock_get_users, mock_get_current_user):
        """测试带分页参数的用户列表"""
        mock_get_current_user.return_value = self.mock_user
        
        mock_response = Mock()
        mock_response.items = []
        mock_response.total = 0
        mock_response.page = 2
        mock_response.size = 10
        mock_response.total_pages = 0
        mock_get_users.return_value = mock_response
        
        # 发送请求
        response = client.get(
            "/api/v1/users/?page=2&size=10&keyword=test",
            headers=self.auth_headers
        )
        
        # 验证响应
        assert response.status_code == 200
        
        # 验证服务调用参数
        mock_get_users.assert_called_once_with(
            page=2,
            size=10,
            keyword="test",
            status=None
        )
    
    @patch('app.core.deps.get_current_user')
    @patch('app.services.user_service.UserService.get_user_by_id')
    def test_get_user_by_id_success(self, mock_get_user, mock_get_current_user):
        """测试根据ID获取用户成功"""
        mock_get_current_user.return_value = self.mock_user
        mock_get_user.return_value = self.mock_user
        
        # 发送请求
        response = client.get("/api/v1/users/1", headers=self.auth_headers)
        
        # 验证响应
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == 1
        assert data["username"] == "testuser"
    
    @patch('app.core.deps.get_current_user')
    @patch('app.services.user_service.UserService.get_user_by_id')
    def test_get_user_by_id_not_found(self, mock_get_user, mock_get_current_user):
        """测试根据ID获取用户不存在"""
        mock_get_current_user.return_value = self.mock_user
        mock_get_user.return_value = None
        
        # 发送请求
        response = client.get("/api/v1/users/999", headers=self.auth_headers)
        
        # 验证响应
        assert response.status_code == 404
        data = response.json()
        assert "用户不存在" in data["detail"]
    
    @patch('app.core.deps.get_current_user')
    @patch('app.services.user_service.UserService.create_user')
    def test_create_user_success(self, mock_create_user, mock_get_current_user):
        """测试创建用户成功"""
        mock_get_current_user.return_value = self.mock_user
        mock_create_user.return_value = self.mock_user
        
        # 请求数据
        user_data = {
            "username": "newuser",
            "email": "newuser@example.com",
            "password": "Password123!",
            "real_name": "新用户",
            "role_ids": [1]
        }
        
        # 发送请求
        response = client.post(
            "/api/v1/users/",
            json=user_data,
            headers=self.auth_headers
        )
        
        # 验证响应
        assert response.status_code == 201
        data = response.json()
        assert data["username"] == "testuser"  # 返回的是mock_user
    
    @patch('app.core.deps.get_current_user')
    def test_create_user_validation_error(self, mock_get_current_user):
        """测试创建用户验证错误"""
        mock_get_current_user.return_value = self.mock_user
        
        # 无效的请求数据
        user_data = {
            "username": "ab",  # 用户名太短
            "email": "invalid-email",  # 无效邮箱
            "password": "123",  # 密码太简单
            "real_name": "",  # 真实姓名为空
            "role_ids": []  # 角色为空
        }
        
        # 发送请求
        response = client.post(
            "/api/v1/users/",
            json=user_data,
            headers=self.auth_headers
        )
        
        # 验证响应
        assert response.status_code == 422
        data = response.json()
        assert "detail" in data
    
    @patch('app.core.deps.get_current_user')
    @patch('app.services.user_service.UserService.update_user')
    def test_update_user_success(self, mock_update_user, mock_get_current_user):
        """测试更新用户成功"""
        mock_get_current_user.return_value = self.mock_user
        
        updated_user = User(
            id=1,
            username="testuser",
            email="updated@example.com",
            real_name="更新的用户",
            status=1,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        mock_update_user.return_value = updated_user
        
        # 更新数据
        update_data = {
            "email": "updated@example.com",
            "real_name": "更新的用户"
        }
        
        # 发送请求
        response = client.put(
            "/api/v1/users/1",
            json=update_data,
            headers=self.auth_headers
        )
        
        # 验证响应
        assert response.status_code == 200
        data = response.json()
        assert data["email"] == "updated@example.com"
        assert data["real_name"] == "更新的用户"
    
    @patch('app.core.deps.get_current_user')
    @patch('app.services.user_service.UserService.delete_user')
    def test_delete_user_success(self, mock_delete_user, mock_get_current_user):
        """测试删除用户成功"""
        mock_get_current_user.return_value = self.mock_user
        mock_delete_user.return_value = True
        
        # 发送请求
        response = client.delete("/api/v1/users/1", headers=self.auth_headers)
        
        # 验证响应
        assert response.status_code == 204
    
    @patch('app.core.deps.get_current_user')
    @patch('app.services.user_service.UserService.delete_user')
    def test_delete_user_not_found(self, mock_delete_user, mock_get_current_user):
        """测试删除不存在的用户"""
        mock_get_current_user.return_value = self.mock_user
        mock_delete_user.return_value = False
        
        # 发送请求
        response = client.delete("/api/v1/users/999", headers=self.auth_headers)
        
        # 验证响应
        assert response.status_code == 404
    
    def test_unauthorized_access(self):
        """测试未授权访问"""
        # 发送请求（无认证头）
        response = client.get("/api/v1/users/")
        
        # 验证响应
        assert response.status_code == 401
    
    @patch('app.core.deps.get_current_user')
    def test_forbidden_access(self, mock_get_current_user):
        """测试权限不足"""
        # 模拟无权限用户
        user_without_permission = User(
            id=2,
            username="normaluser",
            email="normal@example.com",
            real_name="普通用户",
            status=1
        )
        mock_get_current_user.return_value = user_without_permission
        
        with patch('app.core.security.require_permissions') as mock_require:
            mock_require.side_effect = Exception("权限不足")
            
            # 发送请求
            response = client.get("/api/v1/users/", headers=self.auth_headers)
            
            # 验证响应
            assert response.status_code == 500  # 或其他适当的错误码
```

### 3.2 集成测试

#### 3.2.1 端到端测试

```python
# tests/test_integration/test_user_flow.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

from app.main import app
from app.core.database import Base, get_db
from app.models.user import User
from app.models.role import Role
from app.core.security import get_password_hash

# 测试数据库配置
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False},
    poolclass=StaticPool,
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def override_get_db():
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()

app.dependency_overrides[get_db] = override_get_db

class TestUserFlowIntegration:
    """用户流程集成测试"""
    
    @pytest.fixture(autouse=True)
    def setup_database(self):
        """设置测试数据库"""
        # 创建表
        Base.metadata.create_all(bind=engine)
        
        # 创建测试数据
        db = TestingSessionLocal()
        
        # 创建角色
        admin_role = Role(name="admin", description="管理员")
        user_role = Role(name="user", description="普通用户")
        db.add(admin_role)
        db.add(user_role)
        db.commit()
        
        # 创建管理员用户
        admin_user = User(
            username="admin",
            email="admin@example.com",
            real_name="管理员",
            password_hash=get_password_hash("admin123"),
            status=1,
            is_superuser=True
        )
        admin_user.roles = [admin_role]
        db.add(admin_user)
        db.commit()
        
        db.close()
        
        yield
        
        # 清理数据库
        Base.metadata.drop_all(bind=engine)
    
    def test_complete_user_management_flow(self):
        """测试完整的用户管理流程"""
        client = TestClient(app)
        
        # 1. 管理员登录
        login_response = client.post("/api/v1/auth/login", json={
            "username": "admin",
            "password": "admin123",
            "remember_me": False
        })
        assert login_response.status_code == 200
        
        login_data = login_response.json()
        access_token = login_data["access_token"]
        auth_headers = {"Authorization": f"Bearer {access_token}"}
        
        # 2. 获取用户列表（初始为空）
        users_response = client.get("/api/v1/users/", headers=auth_headers)
        assert users_response.status_code == 200
        
        users_data = users_response.json()
        initial_count = users_data["total"]
        
        # 3. 创建新用户
        new_user_data = {
            "username": "testuser",
            "email": "testuser@example.com",
            "password": "TestPassword123!",
            "real_name": "测试用户",
            "role_ids": [2]  # 普通用户角色
        }
        
        create_response = client.post(
            "/api/v1/users/",
            json=new_user_data,
            headers=auth_headers
        )
        assert create_response.status_code == 201
        
        created_user = create_response.json()
        user_id = created_user["id"]
        assert created_user["username"] == "testuser"
        assert created_user["email"] == "testuser@example.com"
        
        # 4. 验证用户列表增加了一个用户
        users_response = client.get("/api/v1/users/", headers=auth_headers)
        assert users_response.status_code == 200
        
        users_data = users_response.json()
        assert users_data["total"] == initial_count + 1
        
        # 5. 获取用户详情
        user_detail_response = client.get(
            f"/api/v1/users/{user_id}",
            headers=auth_headers
        )
        assert user_detail_response.status_code == 200
        
        user_detail = user_detail_response.json()
        assert user_detail["username"] == "testuser"
        
        # 6. 更新用户信息
        update_data = {
            "real_name": "更新的测试用户",
            "email": "updated@example.com"
        }
        
        update_response = client.put(
            f"/api/v1/users/{user_id}",
            json=update_data,
            headers=auth_headers
        )
        assert update_response.status_code == 200
        
        updated_user = update_response.json()
        assert updated_user["real_name"] == "更新的测试用户"
        assert updated_user["email"] == "updated@example.com"
        
        # 7. 验证更新后的用户信息
        user_detail_response = client.get(
            f"/api/v1/users/{user_id}",
            headers=auth_headers
        )
        assert user_detail_response.status_code == 200
        
        user_detail = user_detail_response.json()
        assert user_detail["real_name"] == "更新的测试用户"
        
        # 8. 搜索用户
        search_response = client.get(
            "/api/v1/users/?keyword=更新",
            headers=auth_headers
        )
        assert search_response.status_code == 200
        
        search_data = search_response.json()
        assert search_data["total"] >= 1
        assert any(user["real_name"] == "更新的测试用户" for user in search_data["items"])
        
        # 9. 删除用户
        delete_response = client.delete(
            f"/api/v1/users/{user_id}",
            headers=auth_headers
        )
        assert delete_response.status_code == 204
        
        # 10. 验证用户已被删除
        user_detail_response = client.get(
            f"/api/v1/users/{user_id}",
            headers=auth_headers
        )
        assert user_detail_response.status_code == 404
        
        # 11. 验证用户列表恢复到初始状态
        users_response = client.get("/api/v1/users/", headers=auth_headers)
        assert users_response.status_code == 200
        
        users_data = users_response.json()
        assert users_data["total"] == initial_count
    
    def test_user_authentication_flow(self):
        """测试用户认证流程"""
        client = TestClient(app)
        
        # 1. 管理员登录
        login_response = client.post("/api/v1/auth/login", json={
            "username": "admin",
            "password": "admin123",
            "remember_me": False
        })
        assert login_response.status_code == 200
        
        login_data = login_response.json()
        access_token = login_data["access_token"]
        auth_headers = {"Authorization": f"Bearer {access_token}"}
        
        # 2. 创建测试用户
        new_user_data = {
            "username": "testuser",
            "email": "testuser@example.com",
            "password": "TestPassword123!",
            "real_name": "测试用户",
            "role_ids": [2]
        }
        
        create_response = client.post(
            "/api/v1/users/",
            json=new_user_data,
            headers=auth_headers
        )
        assert create_response.status_code == 201
        
        # 3. 测试用户登录
        user_login_response = client.post("/api/v1/auth/login", json={
            "username": "testuser",
            "password": "TestPassword123!",
            "remember_me": False
        })
        assert user_login_response.status_code == 200
        
        user_login_data = user_login_response.json()
        user_token = user_login_data["access_token"]
        user_auth_headers = {"Authorization": f"Bearer {user_token}"}
        
        # 4. 测试用户访问自己的信息
        profile_response = client.get(
            "/api/v1/auth/profile",
            headers=user_auth_headers
        )
        assert profile_response.status_code == 200
        
        profile_data = profile_response.json()
        assert profile_data["username"] == "testuser"
        
        # 5. 测试用户权限限制（不能访问用户管理）
        users_response = client.get("/api/v1/users/", headers=user_auth_headers)
        assert users_response.status_code == 403  # 权限不足
        
        # 6. 测试登出
        logout_response = client.post("/api/v1/auth/logout", headers=user_auth_headers)
        assert logout_response.status_code == 200
        
        # 7. 验证登出后无法访问受保护资源
        profile_response = client.get(
            "/api/v1/auth/profile",
            headers=user_auth_headers
        )
        assert profile_response.status_code == 401  # 未授权

## 4. 测试工具和配置

### 4.1 前端测试工具

#### 4.1.1 Vitest 配置

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'tests/',
        '**/*.d.ts',
        '**/*.config.*',
        'dist/'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './src')
    }
  }
})
```

#### 4.1.2 测试环境设置

```typescript
// tests/setup.ts
import { config } from '@vue/test-utils'
import { createPinia } from 'pinia'
import ElementPlus from 'element-plus'
import { vi } from 'vitest'

// 全局组件注册
config.global.plugins = [createPinia(), ElementPlus]

// 模拟全局对象
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn()
  }))
})

// 模拟 ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn()
}))

// 模拟 IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn()
}))
```

### 4.2 后端测试工具

#### 4.2.1 Pytest 配置

```python
# pytest.ini
[tool:pytest]
minversion = 6.0
addopts = 
    -ra
    --strict-markers
    --strict-config
    --cov=app
    --cov-report=term-missing
    --cov-report=html:htmlcov
    --cov-report=xml
    --cov-fail-under=80
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests
    api: marks tests as API tests
```

#### 4.2.2 测试数据库配置

```python
# tests/conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool
from fastapi.testclient import TestClient

from app.main import app
from app.core.database import Base, get_db
from app.models.user import User
from app.models.role import Role
from app.core.security import get_password_hash

# 测试数据库URL
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

@pytest.fixture(scope="session")
def engine():
    """创建测试数据库引擎"""
    engine = create_engine(
        SQLALCHEMY_DATABASE_URL,
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
    Base.metadata.create_all(bind=engine)
    yield engine
    Base.metadata.drop_all(bind=engine)

@pytest.fixture(scope="function")
def db_session(engine):
    """创建数据库会话"""
    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    session = TestingSessionLocal()
    yield session
    session.close()

@pytest.fixture(scope="function")
def client(db_session):
    """创建测试客户端"""
    def override_get_db():
        try:
            yield db_session
        finally:
            pass
    
    app.dependency_overrides[get_db] = override_get_db
    yield TestClient(app)
    app.dependency_overrides.clear()

@pytest.fixture
def admin_user(db_session):
    """创建管理员用户"""
    admin_role = Role(name="admin", description="管理员")
    db_session.add(admin_role)
    db_session.commit()
    
    user = User(
        username="admin",
        email="admin@example.com",
        real_name="管理员",
        password_hash=get_password_hash("admin123"),
        status=1,
        is_superuser=True
    )
    user.roles = [admin_role]
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user

@pytest.fixture
def auth_headers(client, admin_user):
    """获取认证头"""
    login_response = client.post("/api/v1/auth/login", json={
        "username": "admin",
        "password": "admin123",
        "remember_me": False
    })
    token = login_response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}
```

## 5. 持续集成测试

### 5.1 GitHub Actions 配置

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  frontend-tests:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Install dependencies
      working-directory: ./frontend
      run: npm ci
    
    - name: Run linting
      working-directory: ./frontend
      run: npm run lint
    
    - name: Run type checking
      working-directory: ./frontend
      run: npm run type-check
    
    - name: Run unit tests
      working-directory: ./frontend
      run: npm run test:unit
    
    - name: Run integration tests
      working-directory: ./frontend
      run: npm run test:integration
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./frontend/coverage/lcov.info
        flags: frontend
        name: frontend-coverage
  
  backend-tests:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        python-version: [3.9, 3.10, 3.11]
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      working-directory: ./backend
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Run linting
      working-directory: ./backend
      run: |
        flake8 app tests
        black --check app tests
        isort --check-only app tests
    
    - name: Run type checking
      working-directory: ./backend
      run: mypy app
    
    - name: Run tests
      working-directory: ./backend
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
      run: |
        pytest -v --cov=app --cov-report=xml
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./backend/coverage.xml
        flags: backend
        name: backend-coverage
  
  e2e-tests:
    runs-on: ubuntu-latest
    needs: [frontend-tests, backend-tests]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Use Node.js 18.x
      uses: actions/setup-node@v3
      with:
        node-version: 18.x
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Set up Python 3.10
      uses: actions/setup-python@v4
      with:
        python-version: 3.10
    
    - name: Install frontend dependencies
      working-directory: ./frontend
      run: npm ci
    
    - name: Install backend dependencies
      working-directory: ./backend
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Build frontend
      working-directory: ./frontend
      run: npm run build
    
    - name: Start backend server
      working-directory: ./backend
      run: |
        uvicorn app.main:app --host 0.0.0.0 --port 8000 &
        sleep 10
    
    - name: Start frontend server
      working-directory: ./frontend
      run: |
        npm run preview &
        sleep 5
    
    - name: Run E2E tests
      working-directory: ./frontend
      run: npm run test:e2e
```

### 5.2 测试报告

#### 5.2.1 覆盖率报告

```json
// package.json scripts
{
  "scripts": {
    "test:unit": "vitest run --coverage",
    "test:integration": "vitest run tests/integration --coverage",
    "test:e2e": "playwright test",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage && open coverage/index.html"
  }
}
```

#### 5.2.2 测试结果通知

```yaml
# .github/workflows/notify.yml
name: Test Results Notification

on:
  workflow_run:
    workflows: ["Tests"]
    types:
      - completed

jobs:
  notify:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    
    steps:
    - name: Notify on failure
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#dev-alerts'
        text: '测试失败！请检查 GitHub Actions 日志。'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

## 6. 测试最佳实践

### 6.1 测试编写原则

#### 6.1.1 AAA 模式

```typescript
// Arrange - Act - Assert 模式
it('应该正确计算总价', () => {
  // Arrange: 准备测试数据
  const items = [
    { price: 100, quantity: 2 },
    { price: 50, quantity: 1 }
  ]
  
  // Act: 执行被测试的操作
  const total = calculateTotal(items)
  
  // Assert: 验证结果
  expect(total).toBe(250)
})
```

#### 6.1.2 测试命名规范

```typescript
// 好的测试命名
describe('UserService', () => {
  describe('createUser', () => {
    it('应该在提供有效数据时成功创建用户', () => {})
    it('应该在用户名已存在时抛出错误', () => {})
    it('应该在邮箱格式无效时抛出错误', () => {})
  })
})

// 避免的测试命名
it('test user creation', () => {})  // 太模糊
it('should work', () => {})         // 没有描述具体行为
```

### 6.2 Mock 和 Stub 使用

#### 6.2.1 API Mock

```typescript
// tests/mocks/api.ts
import { vi } from 'vitest'
import type { User } from '@/types/user'

export const mockUserAPI = {
  getUsers: vi.fn(),
  getUserById: vi.fn(),
  createUser: vi.fn(),
  updateUser: vi.fn(),
  deleteUser: vi.fn()
}

// 在测试中使用
vi.mock('@/api/user', () => ({
  userAPI: mockUserAPI
}))
```

#### 6.2.2 组件 Mock

```typescript
// 模拟子组件
vi.mock('@/components/UserCard.vue', () => ({
  default: {
    name: 'UserCard',
    template: '<div data-testid="user-card">{{ user.username }}</div>',
    props: ['user']
  }
}))
```

### 6.3 测试数据管理

#### 6.3.1 测试数据工厂

```typescript
// tests/factories/user.ts
import type { User } from '@/types/user'

export const createMockUser = (overrides: Partial<User> = {}): User => ({
  id: 1,
  username: 'testuser',
  email: 'test@example.com',
  realName: '测试用户',
  status: 1,
  roles: [],
  createdAt: '2023-01-01T00:00:00Z',
  updatedAt: '2023-01-01T00:00:00Z',
  ...overrides
})

export const createMockUsers = (count: number): User[] => {
  return Array.from({ length: count }, (_, index) => 
    createMockUser({
      id: index + 1,
      username: `user${index + 1}`,
      email: `user${index + 1}@example.com`
    })
  )
}
```

#### 6.3.2 测试数据清理

```python
# tests/utils/database.py
from sqlalchemy.orm import Session
from app.models.user import User
from app.models.role import Role

def clean_database(db: Session):
    """清理测试数据库"""
    db.query(User).delete()
    db.query(Role).delete()
    db.commit()

def create_test_data(db: Session):
    """创建测试数据"""
    # 创建角色
    admin_role = Role(name="admin", description="管理员")
    user_role = Role(name="user", description="普通用户")
    db.add_all([admin_role, user_role])
    db.commit()
    
    return {
        'admin_role': admin_role,
        'user_role': user_role
    }
```

## 7. 性能测试

### 7.1 前端性能测试

#### 7.1.1 组件渲染性能

```typescript
// tests/performance/component-performance.test.ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import UserList from '@/components/UserList.vue'
import { createMockUsers } from '../factories/user'

describe('UserList Performance', () => {
  it('应该在合理时间内渲染大量用户', () => {
    const users = createMockUsers(1000)
    
    const startTime = performance.now()
    
    const wrapper = mount(UserList, {
      props: { users }
    })
    
    const endTime = performance.now()
    const renderTime = endTime - startTime
    
    // 渲染1000个用户应该在100ms内完成
    expect(renderTime).toBeLessThan(100)
    
    // 验证所有用户都被渲染
    const userCards = wrapper.findAll('[data-testid="user-card"]')
    expect(userCards).toHaveLength(1000)
  })
})
```

### 7.2 后端性能测试

#### 7.2.1 API 响应时间测试

```python
# tests/performance/test_api_performance.py
import time
import pytest
from fastapi.testclient import TestClient

def test_get_users_performance(client: TestClient, auth_headers):
    """测试获取用户列表的性能"""
    start_time = time.time()
    
    response = client.get("/api/v1/users/", headers=auth_headers)
    
    end_time = time.time()
    response_time = end_time - start_time
    
    # API 响应时间应该在1秒内
    assert response_time < 1.0
    assert response.status_code == 200

def test_create_user_performance(client: TestClient, auth_headers):
    """测试创建用户的性能"""
    user_data = {
        "username": "perftest",
        "email": "perftest@example.com",
        "password": "Password123!",
        "real_name": "性能测试用户",
        "role_ids": [1]
    }
    
    start_time = time.time()
    
    response = client.post("/api/v1/users/", json=user_data, headers=auth_headers)
    
    end_time = time.time()
    response_time = end_time - start_time
    
    # 创建用户应该在2秒内完成
    assert response_time < 2.0
    assert response.status_code == 201
```

## 8. 总结

### 8.1 测试策略要点

1. **分层测试**: 遵循测试金字塔，确保单元测试、集成测试、端到端测试的合理比例
2. **持续集成**: 在CI/CD流程中自动运行测试，确保代码质量
3. **覆盖率目标**: 维持合理的测试覆盖率，重点关注核心业务逻辑
4. **性能监控**: 定期进行性能测试，确保系统响应时间符合要求

### 8.2 测试文化建设

1. **测试先行**: 鼓励TDD（测试驱动开发）实践
2. **代码审查**: 在代码审查中重点关注测试质量
3. **知识分享**: 定期分享测试最佳实践和工具使用技巧
4. **持续改进**: 根据项目发展不断优化测试策略和工具链

### 8.3 工具链维护

1. **依赖更新**: 定期更新测试框架和工具版本
2. **配置优化**: 根据项目需求调整测试配置
3. **环境一致性**: 确保开发、测试、生产环境的一致性
4. **文档更新**: 及时更新测试相关文档和指南

通过遵循本测试规范，我们能够构建一个可靠、高效的测试体系，确保代码质量和系统稳定性。
